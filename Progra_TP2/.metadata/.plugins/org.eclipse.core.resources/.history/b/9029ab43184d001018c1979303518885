package utiles;

import grafos.*;
import grafos.AlgoritmosGrafos.Dijkstra_resultado;
import red.*;
import cola_de_prioridad.TDA.Cola_prioridad_heap;
import java.util.*;
import cofres.*;

public class SimuladorRed {
	private Red red; // Red específica a simular
	private Cola_prioridad_heap<Pedido> pedidos = new Cola_prioridad_heap<>();
	private List<Robot> disponibles = new ArrayList<>();
	private List<Robot> ocupados = new ArrayList<>();
	private Set<Integer> robopuertos = new HashSet<Integer>();

	public SimuladorRed(Red red) {
		this.red = red;
		this.disponibles.addAll(red.getRobots());
		this.robopuertos = red.getIdsNodosRobopuertos();
	}

	public void agregarPedido(Pedido p) {
		pedidos.encolar(p);
	}

	public void simularTurno() {
		// Asignar pedidos
		while (!pedidos.estaVacia() && !disponibles.isEmpty()) {
			Pedido pedido = pedidos.desencolar();
			Robot mejor = obtenerRobotMasCercano(disponibles, pedido.getcOrigen(), red.getGrafo_red());
			
			//Si no lo puedo atender, pero no debería pasar ojo
			if (mejor == null) {
				pedidos.encolar(pedido);
				break;
			}
			
			List<Nodo> camino = dijkstra(mejor.getNodo_actual(), pedido.getcSolicito().getNodo());
			mejor.asignarViaje(camino, pedido, true);
			disponibles.remove(mejor);
			ocupados.add(mejor);
		}

		// Avanzar robots ocupados
		List<Robot> terminados = new ArrayList<>();
		for (Robot r : ocupados) {
			r.avanzarUnTurno(this); // pasamos el simulador
			if (r.estaLibre()) {
				terminados.add(r);
			}
		}
		ocupados.removeAll(terminados);
		disponibles.addAll(terminados);
	}

	public void reencolarPedido(Pedido nuevo) {
		pedidos.encolar(nuevo);
	}
	
	public RobotElegido obtenerRobotMasCercano(ArrayList<Robot> robots, Cofre cofre, Grafo grafo) {
	    Robot robotMinimo = null;
	    Double distanciaMinima = Double.MAX_VALUE;
	    Double bateriaLlegada = 0.0;
	    
	    Nodo destino = cofre.getNodo(); 

	    for (Robot robotActual : robots) {
	        Nodo origen = robotActual.getNodo_actual();
	        Double bateria = robotActual.getBateria(); 
	        Double cargaMax = robotActual.getCarga_max();

	        //Hacemos un dijkstra del robot al cofre de llegada
	        Dijkstra_resultado resul = AlgoritmosGrafos.dijkstraConBateria(
	            grafo,
	            origen,
	            bateria,
	            cargaMax,
	            this.robopuertos
	        );
	        
	        Map<Integer, Double> costosMinimos = resul.getCostosMinimos();
	        Map<Integer, Double> bateriasMinimas = resul.getMejorBateriaConCostoMinimoDouble();

	        Double distanciaActual = costosMinimos.get(destino.getId());
	        Double bateriaActual = bateriasMinimas.get(destino.getId());
	        
	        //Si tengo nuevo minimo
	        if (Double.compare(distanciaActual, distanciaMinima) < 0) {
	            distanciaMinima = distanciaActual;
	            robotMinimo = robotActual;
	            bateriaLlegada = bateriaActual;
	        }
	    }

	    return new RobotElegido(robotMinimo, distanciaMinima, bateriaLlegada);
	}

	private class RobotElegido
	{
		Robot robot;
		Double distanciaMinima;
		Double bateriaLlegada;
		
		public RobotElegido(Robot robot, Double distanciaMinima, Double bateriaLlegada)
		{
			this.robot=robot;
			this.distanciaMinima = distanciaMinima;
			this.bateriaLlegada = bateriaLlegada;
		}
	}
	
}
