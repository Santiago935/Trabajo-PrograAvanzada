package utiles;

import grafos.*;
import grafos.AlgoritmosGrafos.Dijkstra_resultado;
import red.*;
import cola_de_prioridad.TDA.Cola_prioridad_heap;
import java.util.*;
import cofres.*;

public class SimuladorRed {
	private Red red; // Red específica a simular
	private Cola_prioridad_heap<Pedido> pedidos = new Cola_prioridad_heap<>();
	private List<Robot> disponibles = new ArrayList<>();
	private List<Robot> ocupados = new ArrayList<>();
	private Set<Integer> robopuertos = new HashSet<Integer>();

	public SimuladorRed(Red red) {
		this.red = red;
		this.disponibles.addAll(red.getRobots());
		this.robopuertos = red.getIdsNodosRobopuertos();
	}

	public void agregarPedido(Pedido p) {
		pedidos.encolar(p);
	}

	public void simularTurno() {
		// Asignar pedidos
		while (!pedidos.estaVacia() && !disponibles.isEmpty()) {
			Pedido pedido = pedidos.desencolar();
			Robot mejor = obtenerRobotMasCercano(disponibles, pedido.getcOrigen(), red.getGrafo_red());
			
			//Si no lo puedo atender, pero no debería pasar ojo
			if (mejor == null) {
				pedidos.encolar(pedido);
				break;
			}
			
			List<Nodo> camino = dijkstra(mejor.getNodo_actual(), pedido.getcSolicito().getNodo());
			mejor.asignarViaje(camino, pedido, true);
			disponibles.remove(mejor);
			ocupados.add(mejor);
		}

		// Avanzar robots ocupados
		List<Robot> terminados = new ArrayList<>();
		for (Robot r : ocupados) {
			r.avanzarUnTurno(this); // pasamos el simulador
			if (r.estaLibre()) {
				terminados.add(r);
			}
		}
		ocupados.removeAll(terminados);
		disponibles.addAll(terminados);
	}

	public void reencolarPedido(Pedido nuevo) {
		pedidos.encolar(nuevo);
	}
	
	public Robot obtenerRobotMasCercano(ArrayList<Robot> robots, Cofre cofre, Grafo grafo) {
	    Robot robotMinimo = null;
	    Double distanciaMinima = Double.MAX_VALUE;

	    Nodo destino = cofre.getNodo(); // asumimos que el Cofre tiene acceso a su nodo

	    for (Robot robotActual : robots) {
	        Nodo origen = robotActual.getNodo_actual();
	        Double bateria = robotActual.getBateria(); //Podría ser entero
	        Double cargaMax = robotActual.getCarga_max();

	        Dijkstra_resultado resul = AlgoritmosGrafos.dijkstraConBateria(
	            grafo,
	            origen,
	            bateria,
	            cargaMax,
	            this.robopuertos
	        );
	        
	        Map<Integer, Double> costosMinimos = resul.getCostosMinimos();
	        Map<Integer, Double> bateriasMinimsa = resul.getMejorBateriaConCostoMinimoDouble();

	        
	        
	        if (distanciaActual < distanciaMinima) {
	            distanciaMinima = distanciaActual;
	            robotMinimo = robotActual;
	        }
	    }

	    return robotMinimo;
	}

	
	
}
