package utiles;

import java.util.*;

import cofres.*;
import red.*;

public class Pedido {
	private Cofre cSolicito; //cambiar nombre
	private Cofre cAtendio;
	private Item item;
	private int cantidad;
	private double distancia; 

	public Pedido(Cofre cSolicito, Item item, int cantidad) {
		this.cSolicito = cSolicito;
		this.item = item;
		this.cantidad = cantidad;
	}

	public void AtenderPedido(Cofre cofreQueAtendera) {
		if(this.cAtendio != null) // si el pedido ya fue atendido
			return;

		this.cAtendio = cofreQueAtendera;

		//calculo de la distancia
		this.distancia = Coordenada.distancia_eucladiana(this.cSolicito.getCoordenada() ,  this.cAtendio.getCoordenada());
	}

	public Cofre getcSolicito() {
		return cSolicito;
	}

	public Cofre getcAtendio() {
		return cAtendio;
	}

	public Item getItem() {
		return item;
	}

	public int getCantidad() {
		return cantidad;
	}

	public double getDistancia() {
		return distancia;
	}

	@Override
	public String toString() {
		return "Pedido [cSolicito=" + cSolicito + ", cAtendio=" + cAtendio + ", item=" + item + ", cantidad=" + cantidad
				+ ", distancia=" + distancia + ", robotAsignadoMasCercano=" + robotAsignado + "]";
	}


	//Asignacion de robots

	public void asignarRobot(Robot robot) {
	    this.robotAsignado = robot;
	}

	public Robot getRobotAsignado() {
	    return robotAsignado;
	}

	
	public static ArrayList<Pedido> armado_pedidos2(ArrayList<Red> redes) {
		ArrayList<Pedido> pedidos = new ArrayList<>();

		// 1) Recorrer cada red
		for (Red red : redes) {
			ArrayList<Cofre> cofres = red.getCofres();

			// 1.a) Filtrar cofres solicitantes
			List<CofreSolicitud> solicitantes = new ArrayList<>();
			List<Cofre> ofertantesOrdenados = new ArrayList<>();

			for (Cofre c : cofres) {
				if (c instanceof CofreSolicitud) {
					solicitantes.add((CofreSolicitud) c);
				} else if (c instanceof CofreProvisionActiva/* || c instanceof CofreBuffer || c instanceof CofreProvisionPasiva*/) {
					ofertantesOrdenados.add(c); // se agregan todos y se prioriza luego
				}
			}

			/*
			// Ordenamos ofertantes según prioridad: activa > buffer > pasiva
			ofertantesOrdenados.sort((a, b) -> {
				if (a instanceof CofreProvisionActiva) return -1;
				if (b instanceof CofreProvisionActiva) return 1;
				if (a instanceof CofreBuffer) return -1;
				if (b instanceof CofreBuffer) return 1;
				return 0;
			});*/

			// 2) Por cada cofre solicitante
			for (CofreSolicitud solicitante : solicitantes) {
				Map<Item, Integer> pedidosPendientes = new HashMap<>(solicitante.getPedidos());

				// 3) Para cada ítem solicitado
				for (Map.Entry<Item, Integer> entry : pedidosPendientes.entrySet()) {
					Item item = entry.getKey();
					int cantidadNecesaria = entry.getValue();

					if (cantidadNecesaria <= 0) continue; // Por si pide 0

					// 4) Buscar cofres ofertantes con stock
					for (Cofre ofertante : ofertantesOrdenados) {
						int stockDisponible = ofertante.consultarStock(item);

						if (stockDisponible <= 0) continue;

						int cantidadAtendida = Math.min(cantidadNecesaria, stockDisponible);

						boolean pudoReservar = ofertante.reservarItem(item, cantidadAtendida);
						if (pudoReservar) {
							solicitante.atenderSolicitud(item, cantidadAtendida);
							Pedido nuevoPedido = new Pedido(solicitante, item, cantidadAtendida);
							pedidos.add(nuevoPedido);

							cantidadNecesaria -= cantidadAtendida;

							if (cantidadNecesaria <= 0) break; // ítem completamente atendido
						}
					}
				}
			}
		}

		return pedidos;
	}

	
	
	public static ArrayList<Pedido> armado_pedidos(ArrayList<Red> redes) {
		ArrayList<Pedido> pedidos = new ArrayList<>();

		// 1) llenamos los pedidos con solicitudes de cofres que solicitan
		for (Red red : redes) {
			// para cada cofre dentro de la red
			for (Cofre c : red.getCofres()) {

				if (c instanceof CofreSolicitud) { // si es un cofre de solicitud
					CofreSolicitud cofreSolicitud = (CofreSolicitud) c;

					// Iteramos por cada pedido: cada item y su cantidad
					for (Item item : cofreSolicitud.getPedidos().keySet()) {
						int cantidad = cofreSolicitud.consultarCantidadSolicitada(item);

						// Creamos un nuevo Pedido con el cofre que solicita, el item y la cantidad
						Pedido pedido = new Pedido(cofreSolicitud, item, cantidad);

						// Lo agregamos a la lista de pedidos a procesar
						pedidos.add(pedido);
					}
				}
			}
		}

		// Este item se deberia cambiar por
		// - consultar con cofres de provision activa
		// - si no hay ninguno de provision activa, consultar con cofres buffer
		// - si no hay ninguno de buffer, consultar con cofres pasivos
		// 2) atendemos los pedidos con cofres de provisión activa de la misma red
		for (Pedido pedido : pedidos) { // para cada pedido
			CofreSolicitud cofreSolicitante = (CofreSolicitud) pedido.getcSolicito();
			Item itemPedido = pedido.getItem();
			int cantidadPedido = pedido.getCantidad();

			// Buscar la red a la que pertenece el cofre solicitante
			Red redCorrespondiente = null;
			for (Red red : redes) {
				if (red.getCofres().contains(cofreSolicitante)) {
					redCorrespondiente = red;
					break;
				}
			}

			if (redCorrespondiente == null) {
				// No se encontró la red, no se puede atender este pedido
				continue;
			}

			// Buscar cofre de provisión activa que tenga stock suficiente
			CofreProvisionActiva cofreAtendedor = null;
			int maxStock = 0;

			for (Cofre cofre : redCorrespondiente.getCofres()) {
				if (cofre instanceof CofreProvisionActiva) {
					CofreProvisionActiva cofreProvision = (CofreProvisionActiva) cofre;
					int stockDisponible = cofreProvision.consultarStock(itemPedido);

					// ESTA PARTE DEL CODIGO SE PODRIA MEJORAR
					// El cofre que atiende es el que tenga mayor stock
					if (stockDisponible >= cantidadPedido && stockDisponible > maxStock) {
						maxStock = stockDisponible;
						cofreAtendedor = cofreProvision;
					}
				}
			}

			if (cofreAtendedor != null) {
				// Atendemos el pedido: descontamos stock y marcamos quién atendió
				boolean pudoSacar = cofreAtendedor.sacarItem(itemPedido, cantidadPedido);
				if (pudoSacar) {
					pedido.AtenderPedido(cofreAtendedor);

					// También descontamos la solicitud del cofre solicitante
					cofreSolicitante.atenderSolicitud(itemPedido, cantidadPedido);
				}
			}
			// Si no hay cofre que pueda atender, el pedido queda sin atender
		}

		return pedidos;
	}

}