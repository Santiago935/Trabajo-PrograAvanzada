package red;

import utiles.*;
import cofres.*;
import grafos.*;

public class Robot {
	private String id;
	private final double carga_max = 20.0;
	private int carga_actual;
	private Nodo nodo_actual;
	private double bateria;

	private Pedido pedidoEnCurso;
	private int distanciaRestante;
	private boolean yendoAlSolicitante; // true: ida a origen, false: ida a destino
	
	
	public Robot(String id, Nodo nodo_inicial) {
		this.nodo_actual = nodo_inicial;
		this.bateria = 100;
		this.carga_actual = 0;
	}

	public void viajar(Nodo nodo_destino, double costo) {
		// Mi Arista está implementada con int para el peso
		// Para el algoritmo que vayamos a usar, debo cambiar eso y ver como fluctuan
		// los
		// resultados...
		try {
			if (this.bateria - costo > 0) {
				this.bateria -= costo;
				this.nodo_actual = nodo_destino;
			} else {
				throw new Exception("No hay suficiente batería para realizar la acción.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	public String getId() {
		return id;
	}

	public double getCarga_max() {
		return carga_max;
	}

	public int getCarga_actual() {
		return carga_actual;
	}

	public Nodo getNodo_actual() {
		return nodo_actual;
	}

	public double getBateria() {
		return bateria;
	}

	@Override
	public String toString() {
		return "Robot [id=" + id + ", carga_actual=" + carga_actual + "]";
	}
	
	
	public void asignarPedido(Pedido pedido, int distancia, boolean ida) {
		this.pedidoEnCurso = pedido;
		this.distanciaRestante = distancia;
		this.yendoAlSolicitante = ida;
	}

	public void avanzarUnTurno(SimuladorRed sim) {
		if (pedidoEnCurso == null) return;

		if (distanciaRestante > 0) {
			distanciaRestante--;
			// eventualmente podés reducir batería también acá
		}

		if (distanciaRestante == 0) {
			if (yendoAlSolicitante) {
				Cofre origen = pedidoEnCurso.getcSolicito();
				int disponible = origen.cargarRobot(this, pedidoEnCurso.getItem(), pedidoEnCurso.getCantidad());

				if (disponible < pedidoEnCurso.getCantidad()) {
					int restante = pedidoEnCurso.getCantidad() - disponible;
					Pedido nuevo = new Pedido(origen, pedidoEnCurso.getcAtendio(), pedidoEnCurso.getItem(), restante);
					sim.reencolarPedido(nuevo);
				}

				int nuevaDistancia = AlgoritmosGrafos.dijkstraConBateria(
					sim.getRed().getGrafo_red(),
					nodo_actual,
					bateria,
					carga_max,
					pedidoEnCurso.getcAtendio().getNodo()
				);
				asignarPedido(pedidoEnCurso, nuevaDistancia, false);
			} else {
				Cofre destino = pedidoEnCurso.getcAtendio();
				destino.descargarRobot(this, pedidoEnCurso.getItem(), carga_actual);
				carga_actual = 0;
				pedidoEnCurso = null;
				sim.robotDisponible(this);
			}
		}
	}

	public boolean estaLibre() {
		return pedidoEnCurso == null;
	}
}

}