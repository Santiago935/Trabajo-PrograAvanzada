package utiles;

import java.util.*;

import cofres.*;
import cola_de_prioridad.TDA.Cola_prioridad_heap;
import red.*;

public class Pedido implements Comparable<Pedido>{
	private Cofre cSolicito; //cambiar nombre
	private Cofre cAtendio;
	private Item item;
	private int cantidad;
	private double distancia; 

	public Pedido(Cofre cSolicito, Cofre cAtendio, Item item, int cantidad) {
		this.cSolicito = cSolicito;
		this.cAtendio = cAtendio;
		this.item = item;
		this.cantidad = cantidad;
		// Agregar distancia
	}

	public void AtenderPedido(Cofre cofreQueAtendera) {
		if(this.cAtendio != null) // si el pedido ya fue atendido
			return;

		this.cAtendio = cofreQueAtendera;

		//calculo de la distancia
		this.distancia = Coordenada.distancia_eucladiana(this.cSolicito.getCoordenada() ,  this.cAtendio.getCoordenada());
	}

	public Cofre getcSolicito() {
		return cSolicito;
	}

	public Cofre getcAtendio() {
		return cAtendio;
	}

	public Item getItem() {
		return item;
	}

	public int getCantidad() {
		return cantidad;
	}

	public double getDistancia() {
		return distancia;
	}

	@Override
	public String toString() {
		return "Pedido [cSolicito=" + cSolicito + ", cAtendio=" + cAtendio + ", item=" + item + ", cantidad=" + cantidad
				+ ", distancia=" + distancia + "]";
	}


	@Override
	public int compareTo(Pedido otroPedido)
	{
		return Double.compare(this.distancia, otroPedido.distancia);
	}

	
	public static ArrayList<Pedido> armado_pedidos2(ArrayList<Red> redes) {
		ArrayList<Pedido> pedidos = new ArrayList<>();

		// 1) Recorrer cada red
		for (Red red : redes) {
			ArrayList<Cofre> cofres = (ArrayList<Cofre>) red.getCofres();

			// 1.a) Filtrar cofres solicitantes
			List<CofreSolicitud> solicitantes = new ArrayList<>();
			List<Cofre> ofertantesOrdenados = new ArrayList<>();

			for (Cofre c : cofres) {
				if (c instanceof CofreSolicitud) {
					solicitantes.add((CofreSolicitud) c);
				} else if (c instanceof CofreProvisionActiva/* || c instanceof CofreBuffer || c instanceof CofreProvisionPasiva*/) {
					ofertantesOrdenados.add(c); // se agregan todos y se prioriza luego
				}
			}

			/*
			// Ordenamos ofertantes según prioridad: activa > buffer > pasiva
			ofertantesOrdenados.sort((a, b) -> {
				if (a instanceof CofreProvisionActiva) return -1;
				if (b instanceof CofreProvisionActiva) return 1;
				if (a instanceof CofreBuffer) return -1;
				if (b instanceof CofreBuffer) return 1;
				return 0;
			});*/

			// 2) Por cada cofre solicitante
			for (CofreSolicitud solicitante : solicitantes) {
				Map<Item, Integer> pedidosPendientes = new HashMap<>(solicitante.getPedidos());

				// 3) Para cada ítem solicitado
				for (Map.Entry<Item, Integer> entry : pedidosPendientes.entrySet()) {
					Item item = entry.getKey();
					int cantidadNecesaria = entry.getValue();

					if (cantidadNecesaria <= 0) continue; // Por si pide 0

					// 4) Buscar cofres ofertantes con stock
					for (Cofre ofertante : ofertantesOrdenados) {
						int stockDisponible = ofertante.consultarStock(item);

						if (stockDisponible <= 0) continue;
						
						//Tomo el minimo entre el que necesito y el que tengo
						int cantidadAtendida = Math.min(cantidadNecesaria, stockDisponible);
						
						//Reservo en el ofertante
						boolean pudoReservar = ofertante.aceptarSolicitud(item, cantidadAtendida);
						if (pudoReservar) {
							solicitante.aceptarSolicitud(item, cantidadAtendida); // Acepto el pedido
							Pedido nuevoPedido = new Pedido(solicitante, ofertante, item, cantidadAtendida); //Armo el pedido
							pedidos.add(nuevoPedido); //Lo agrego a la lista

							cantidadNecesaria -= cantidadAtendida; //Resto lo otorgado

							if (cantidadNecesaria <= 0) break; // ítem completamente atendido
							//Si no es 0, sigo buscando ofertantes
						}
					}
				}
			}
		}

		return pedidos;
	}

	
	public static Cola_prioridad_heap<Pedido> obtenerPedidosOrdenados(ArrayList<Pedido> listaDesordenada)
	{
		Cola_prioridad_heap<> pedidos = new Cola_prioridad_heap<Pedido>();
		
		for (Pedido pedido : listaDesordenada) {
			pedidos.encolar(pedido);
		}
		
		return pedidos;
	}
	
	
	
//FIN
}